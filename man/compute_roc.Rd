% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mod_roc.R
\name{compute_roc}
\alias{compute_roc}
\alias{assert_compute_roc_data}
\alias{compute_roc_data}
\title{Helpers for computing ROC data from the subset dataset}
\usage{
assert_compute_roc_data(r, with_ci)

compute_roc_data(predictor, response, do_bootstrap, ci_points)
}
\arguments{
\item{r}{\verb{[list(data.frame())]}

dataframe resulting from compute_roc_data}

\item{with_ci}{\verb{[logical(1)]}

Indicates if CI is included in the result}

\item{predictor}{\verb{[numeric(n)]}

The scores of the predictor}

\item{response}{\verb{[factor(n)]}

The response value}

\item{do_bootstrap}{\verb{[logical(1)]}
Calculate confidence intervals for sensitivity and specificity}

\item{ci_points}{\verb{[list(spec = numeric(), thr = numeric())]}
Points at which 95\% confidence intervals for sensitivity and specificity will be calculated. Depending on the entry
CI will be calculated at defined specificity points or threshold points.}
}
\value{
\verb{[list(data.frame())]}

A list with entries:
\subsection{\code{roc_curve}}{

\verb{[data.frame()]}

With columns:
\itemize{
\item \code{specificity} \verb{[numeric()]}: Sensitivity
\item \code{sensitivity} \verb{[numeric()]}: Specificity
\item \code{threshold} \verb{[numeric()]}: Threshold
\item \code{auc} \verb{[numeric(3)]}: A numeric vector of length 3 c(LOWER AUC CI, AUC, UPPER AUC CI)
\item \code{direction} \verb{[character(1)]}: The direction of the comparisons \code{<} or \code{>} according to \code{levels}
\item \code{levels} \verb{[character(2)]}: The sorted levels of the response variable according to \code{direction}
}
}

\subsection{\code{roc_ci}}{

\verb{[data.frame()]}

With columns:
\itemize{
\item \code{ci_specificity} \verb{[numeric()]}: Specificity value
\item \code{ci_lower_specificity} \verb{[numeric()]}: Specificity lower confidence interval
\item \code{ci_upper_specificity} \verb{[numeric()]}: Specificity upper confidence interval
\item \code{ci_sensitivity} \verb{[numeric()]}: Sensitivity value
\item \code{ci_lower_sensitivity} \verb{[numeric()]}: Sensitivity lower confidence interval
\item \code{ci_upper_sensitivity} \verb{[numeric()]}: Sensitivity upper confidence interval
\item \code{threshold} \verb{[numeric()]}: Threshold
}
}

\subsection{\code{roc_optimal_cut}}{

\verb{[data.frame()]}

With columns:
\itemize{
\item \code{optimal_cut_title} \verb{[character()]}: Name of the optimal cut
\item \code{optimal_cut_specificity} \verb{[numeric()]}: Sensitivity at the optimal cut point
\item \code{optimal_cut_lower_specificity} \verb{[numeric()]}: Lower Confidence interval of sensitivity
\item \code{optimal_cut_upper_specificity} \verb{[numeric()]}: Upper Confidence interval of sensitivity
\item \code{optimal_cut_sensitivity} \verb{[numeric()]}: Specificity at the optimal cut point
\item \code{optimal_cut_lower_sensitivity} \verb{[numeric()]}: Lower Confidence interval of sensitivity
\item \code{optimal_cut_upper_sensitivity} \verb{[numeric()]}: Upper Confidence interval of sensitivity
\item \code{optimal_cut_threshold} \verb{[numeric()]}: Threshold of optimal cut
}
}
}
\description{
Helpers for computing ROC data from the subset dataset
}
\details{
\itemize{
\item Computing CIs for sensitivity and specifity usually implies using bootstrap which can be too expensive,
therefore the option of not running calculating them when the function is invoked is included.
\item Response levels are selected alphabetically being \code{case} the first one alphabetically the comparison direction
is selected automatically by \code{\link[pROC:roc]{pROC::roc()}} and related functions.
\item CIs are expected to be 95\% CIs
}
}
\section{Functions}{
\itemize{
\item \code{assert_compute_roc_data()}: Assert compute_roc result data.frame types are correct

\item \code{compute_roc_data()}: Compute ROC analysis

}}
\keyword{compute}
